---
layout: default
slug: indkeynote
---

<h2>Industry Track Keynote Speaker</h2>

<div class="col-xs-12" style="height:25px;"></div>

<div class="row">
  <a name="VadimZaytsev"></a>
  <div class="col-md-3">
    <!--<img class="keynote-face" src="/assets/faces/vadimzaytsev.jpg"/>-->
    <p>
      Vadim Zaytsev<br/>
      <a href="http://www.raincode.com/">Raincode</a><br/>
      Belgium
    </p>
  </div>
  <div class="col-md-9">
    <p class="text-justify">    
    Vadim Zaytsev has a publication track record in <a href="http://grammarware.net/writes/">pure and applied research</a>, has supervised <a href="http://grammarware.github.io/master/">more than  25 graduate students</a>, and currently works as a Chief Science Officer at Raincode, a company recently prized by Microsoft as the top performer in mainframe migration.
    </p>

    <h3>Two Sides of Grammarware Engineering</h3>

    <p class="text-justify">
    <strong>Abstract.</strong>
    The worlds of industrial software engineering and of academic computer
science research have a mutual love-hate relation. University
researchers investigate problems that have never been solved before,
reluctantly replicate experiments done by others and tend to look down
on simple people they call "practitioners" that concern themselves
with routine tasks of coding, testing and maintenance, which are of
course trivial, yet they are being increasingly expected to
demonstrate their ability to collaborate with software companies and
the relevance of their solutions for them. On the opposite side,
"true" software developers have a lot of respect for doctoral and
professorial titles and achievements, which they effortlessly combine
with a universal assumption that anyone with an extensive academic
background ultimately lacks any technical knowledge and any
practically useful skills.</p>
    <p class="text-justify">
The keynote story will unfold around a journey of a grammar engineer
versed in both scientific research and computer programming, following
his transitions from research on grammars to teaching software
engineering to analysing legacy code and developing migration tools.
We will see examples of grammar and compiler engineering, reverse
engineering and re-engineering undertaken in industrial and academic
contexts, seek similarities, mismatches and lessons to be learnt.
    </p>
  </div>
</div>

